C======================================================================
C  WH_ROOTGR, Subroutine
C
C  Computes Daily Root Growth and Distribution
C----------------------------------------------------------------------
C  Revision history
C
C  1. Written
C  2  Modified by                           E. Alocilja & B. Baer 9-88
C  3  Modified by                           T. Jou                4-89
C  4. Header revision and minor changes             P.W.W.      2-8-93
C  5. Added switch block, etc.                      P.W.W.      2-8-93
C  6. Simplified the RLNEW calculation and slowed
C     the growth of roots in deeper soils.   J.T.R. & B.D.B.    6-20-94
C  7. Converted to modular routine                  W.D.B.      4-01-01
C  8. Further modular changes                       W.D.B      12-01-01
C  9. Created WH_NUPTAK.FOR for APSIM NWheat        F.S.R.      6-27-11
C----------------------------------------------------------------------
C  Called by : WH_APSIM
C
C  Calls  : None
C----------------------------------------------------------------------

      SUBROUTINE WH_ROOTGR (CONTROL,ISWNIT,                       !C
     &        CUMDEP,CUMDTT,DEPMAX,DLAYR,DTT,ESW,GRORT,ISTAGE,    !I
     %        LL,DUL,NO3,NH4,NLAYR,PLTPOP,PORMIN,RLWR,SAT,SDEPTH, !I
     %        SHF,STGDOY,SW,SWFAC,YRDOY,                          !I
     %        RTDEP,RLV)            


C----------------------------------------------------------------------
      USE ModuleDefs
      IMPLICIT  NONE
      SAVE

      INTEGER     DYNAMIC     

      REAL        CUMDEP     
      REAL        CUMDTT      
      REAL        DEPMAX      
      REAL        DLAYR(NL)   
      REAL        DTT    
      REAL        DUL(NL)          
      REAL        ESW(NL)     
      REAL        GRORT       
      INTEGER     ISTAGE      
      CHARACTER   ISWNIT*1    
      INTEGER     L           
      INTEGER     L1          
      REAL        LL(NL)      
      REAL        NH4(NL)     
      INTEGER     NLAYR       
      REAL        NO3(NL)     
      REAL        PLTPOP 
	REAL        PORMIN     
      REAL        RLDF(NL)    
                              
      REAL        RLNEW      
      REAL        RLV(NL)    
      REAL        RLWR       
      REAL        RNFAC      
                             
      REAL        RNLF       
                             
      REAL        RTDEP 
	REAL        RTEXF     
	REAL        RTSURV
      REAL        SDEPTH     
      REAL        SHF(NL)    
      INTEGER     STGDOY(20) 
      REAL        SW(NL)     
	REAL        SAT(NL)
      REAL        SWDF       
      REAL        SWEXF                       
      REAL        SWFAC      
      REAL        TRLDF      
      INTEGER     YRDOY       

!     The variable "CONTROL" is of type "ControlType".
      TYPE (ControlType) CONTROL
      
      DYNAMIC = CONTROL % DYNAMIC

C----------------------------------------------------------------------
C            DYNAMIC = RUNINIT OR SEASINIT
C----------------------------------------------------------------------
      IF(DYNAMIC.EQ.RUNINIT.OR.DYNAMIC.EQ.SEASINIT) THEN
 
          DO L = 1, NL
              RLV(L) = 0.0
              ESW(L) = DUL(L)-LL(L)
              RLDF(L) = 0.0
          END DO
          RTDEP = 0.0
          RNLF  = 0.0
          RNFAC = 0.0
          RLNEW = 0.0

C----------------------------------------------------------------------
C             DYNAMIC = INTEGR
C----------------------------------------------------------------------

      ELSEIF(DYNAMIC.EQ.INTEGR) THEN
          IF(ISTAGE.EQ.7.OR.ISTAGE.EQ.8) RTDEP  = SDEPTH             
          IF(ISTAGE.EQ.9) RTDEP  = RTDEP + 0.15*DTT
          

          IF(YRDOY.EQ.STGDOY(9)) THEN
              CUMDEP = 0.0
              DO L = 1, NLAYR
                  CUMDEP = CUMDEP + DLAYR(L)
                  RLV(L) = 0.20*PLTPOP/DLAYR (L)
                  IF (CUMDEP .GT. RTDEP) GO TO 100            ! Was EXIT
              END DO

  100         CONTINUE                                       ! Sun Fix
              RLV(L) = RLV(L)*(1.0-(CUMDEP-RTDEP)/DLAYR(L))
              L1 = L + 1
              IF (L1 .LT. NLAYR) THEN
                  DO L = L1, NLAYR
                      RLV(L) = 0.0
                  END DO
              ENDIF
          ENDIF


      !----------------------------------------------------------------
      !                   Grow Roots
      !----------------------------------------------------------------

          IF (GRORT.LE.0.0001) GOTO 999

!The small differences between root length/weight ratios used in earlier
!models were insignificant considering the uncertainty of the value
!and the uncertainty of loss of assimilate by exudation and respiration.
!A compromise value of 0.98 was choosen for all crops.

          RLNEW  = GRORT * RLWR * PLTPOP   ! A compromise value -- JTR
          CUMDEP = 0.0
          RNFAC  = 1.0
          L      = 0

          DO WHILE ((CUMDEP .LT. RTDEP) .AND. (L .LT. NLAYR))
              L = L + 1
              CUMDEP = CUMDEP + DLAYR(L)
              IF (SW(L)-LL(L) .LT. 0.25*ESW(L)) THEN
                  SWDF = 4.0*(SW(L)-LL(L))/ESW(L)
                  IF (SWDF .LT. 0.0) THEN
                      SWDF = 0.0
                  ENDIF
              ELSE
                  SWDF = 1.0
              ENDIF

      !Made all crops so that RNFAC is constrained between 0.01 and 1.0;
      !on page 94 of Jones & Kiniry book the minimum is 0.01. - WTB

              IF (ISWNIT .NE. 'N') THEN
                  RNFAC = 1.0 - (1.17*EXP(-0.15*(NO3(L)+NH4(L))))
                  RNFAC = AMAX1 (RNFAC,0.01)
              ENDIF

              RLDF(L) = AMIN1(SWDF,RNFAC)*SHF(L)*DLAYR (L)
          END DO

          L1 = L

!The following changes were made to simplify the code and make the model
!more generic. It also takes into account some newer data provided by
!Julio Dardenelli of Argentina.  For the first time the ceres model
!restricts the rate of downward movement of roots with the soil property
!-- root weighting factor -- to account for greater difficulty in growing
!downward in hard soil. Changes made by JTR 6/16/94.


c** wdb 10/22/03  
          RTEXF = 0.1
          SWEXF = 1.0
          IF (SAT(L)-SW(L) .LT. PORMIN) THEN
            SWEXF = (SAT(L) - SW(L)) / PORMIN
            SWEXF = MIN(SWEXF, 1.0)
          ENDIF

          RTSURV = MIN(1.0,(1.-RTEXF*(1.-SWEXF)))

c** wdb 10/22/03
          IF (CUMDTT .LT. 275.0) THEN             ! JTR 6/17/94
              RTDEP = RTDEP + DTT*0.1*SQRT(SHF(L)*AMIN1(SWFAC*2.0,SWDF))
!              RTDEP = RTDEP + DTT*0.1*SQRT(SHF(L)*AMIN1(SWFAC*2.0,SWDF,satfac))
          ELSE
              RTDEP = RTDEP + DTT*0.2*SQRT(SHF(L)*AMIN1(SWFAC*2.0,SWDF))
          ENDIF

          RTDEP    = AMIN1 (RTDEP,DEPMAX)                            
          RLDF(L1) = RLDF(L1)*(1.0-(CUMDEP-RTDEP)/DLAYR(L1))
          TRLDF    = 0.0

          DO  L = 1, L1
              TRLDF = TRLDF + RLDF(L)
          END DO

          IF (TRLDF .GE. RLNEW*0.00001) THEN
              RNLF = RLNEW/TRLDF
              DO L = 1, L1
                  RLV(L) = RLV(L) + RLDF(L)*RNLF/DLAYR(L)-0.005*RLV(L)
                  !Round off to nearest 1/1000th place
	            RLV(L) = RLV(L) * RTSURV
                  RLV(L) = REAL(INT(RLV(L)*1000.))/1000.  
                  RLV(L) = AMAX1 (RLV(L),0.0)
                  RLV(L) = AMIN1 (RLV(L),4.0)
              END DO
          ENDIF


C----------------------------------------------------------------------
C                     DYNAMIC = OUTPUT
C----------------------------------------------------------------------
      ELSEIF(DYNAMIC.EQ.OUTPUT) THEN

      ! {no procedures to date}

      ENDIF !Dynamic loop

999   CONTINUE
      RETURN
      END SUBROUTINE WH_ROOTGR
C=======================================================================
C  nwheats_set_adf, Subroutine  
C    Returns 
C    this is a new routine for senthold's stuff.
C-----------------------------------------------------------------------
C  REVISION HISTORY
C  02/28/2012  FSR adapted from nwheats
!-----------------------------------------------------------------------
C  Called by: nwheats_crppr
C  Calls    : integer nwheats_level, nwheats_ad_rtloss
C=======================================================================
      SUBROUTINE nwheats_set_adf (CONTROL,
     &    dlayr_nw, duldep, istage, mxlayr, nrlayr,              !Input 
     &    p4af, p5af, p6af,                                      !Input
     &    swdep, xstage,                                         !Input
     &    adf, afs)                                              !Output

!     ------------------------------------------------------------------
      USE ModuleDefs    
      IMPLICIT NONE
      SAVE
  
      integer count_of_real_vals
      integer istage
      integer L         ! layer no.
      integer mxlayr    !
      integer nlayr_nw  ! no. of layers
      integer nrlayr    ! no. of root layers
      integer num_stage ! (maybe real?)
      integer nwheats_level ! Function from nwheats. Returns layer  
                            ! number of depth in profile dlayr_nw
      real adf(mxlayr)  !  ?
      real ADLAI        ! threshold aeration deficit (AF2) affecting LAI
      real ADPHO  ! threshold aeration deficit (AF2) affecting tillering
      real ADTIL  ! threshold aeration deficit (AF2) affecting photosyn
      real afs          ! 
      real af1          ! AD affecting root system as a base for 
                        ! above-ground crop effect
      real af1_time
      real af2          ! Aeration factor (?)
      real af2_lai 
      real af2_tiller
      real af2_photo
      real ALIN
      real dlayr_nw(mxlayr) !  
      real duldep(mxlayr)! drained upper limit by soil layer      
      real fdsw         ! fraction of drainable soil water (0-1)
      real num_fdsw     !Number of parameter values returned for fdsw(?)
      real p4af         !Days until aeration deficit affects root growth
      real p5af         ! Cultivar specific power term
      real p6af         !  
      real p_adf        ! (may be soil parameter - FSR)
      real p_afs        !
      real p_fdsw       ! (may be soil parameter - FSR)
      real p_stage
      real rtdep_nw     ! root depth in deepest root layer (mm) (?)
      real satdep(mxlayr)! (may be soil parameter - FSR)
      real sum_adf      ! sum of all adf's across root layers
      real sum_real_array ! Function in WH_SW_SUBS.for
      real swdep(mxlayr)! water content by soil layer (mm) (?)
      real xstage       ! growth stage index for use in plant nitrogen

!     The variable "CONTROL" is of type "ControlType".
      TYPE (ControlType) CONTROL


      nlayr_nw = count_of_real_vals (dlayr_nw, mxlayr)
 
      do L = 1, nlayr_nw
         ! calculate fraction of drainable soil water
!*!      fdsw = divide(swdep(L)-duldep(L),satdep(L)-duldep(L),0.0)
         if((satdep(L)-duldep(L)) .GT. 0.0) then
            fdsw = (swdep(L)-duldep(L)) / (satdep(L)-duldep(L))
         else
            fdsw = 0.0
         endif
!*!      fdsw = bound (fdsw,0.0,1.0)
         fdsw = MAX (fdsw, 0.0)
         fdsw = MIN (fdsw, 1.0)
!*!      adf(L) = linear_interp_real(fdsw,p_fdsw,p_adf,num_fdsw)
!*! Temp solution - FSR   adf(L) = ALIN(fdsw,p_fdsw,p_adf,num_fdsw) 
      enddo
 
      ! Root killing routine
!*! Temp solution - FSR   call nwheats_ad_rtloss()
 
      ! find no. of layers with roots
         nrlayr = nwheats_level(rtdep_nw, dlayr_nw, mxlayr)
                 
 
      ! sum adf across all layers with roots
      sum_adf = sum_real_array(adf,nrlayr)
 
      ! Calculate AF1, AD affecting root system as a base for
      ! above-ground crop effect.
!*!   af1 = divide (sum_adf,real(nrlayr),0.0)**p5af
      if(nrlayr .GT. 0) then 
         af1 = (sum_adf / real(nrlayr))**p5af
      else
         af1 = 0.0
      endif

      ! Find time for which af1 < threshold value
      if (af1.lt.p6af) then
         af1_time = af1_time + 1
      else
         af1_time = 0
      endif
 
      ! Get phenological sensitivity to AD
      if ((xstage.ge.1).and.(xstage.le.6)) then
!*!      afs = linear_interp_real (xstage, p_stage, p_afs, num_stage)
!*! Temp solution - FSR   afs = ALIN (xstage, p_stage, p_afs, num_stage)
      else
         afs = 1.0
      endif
 
      ! If time of AD is > p4af then calculate crop effect AF2 and
      ! related stresses for growth components
      if (af1_time .ge. p4af) then
 
         af2 = max(af1,afs)
 
         if (af2 .lt. ADLAI) then
            af2_lai = min(af2,1.0)
         else
            af2_lai = 1.0
         endif
 
         if (af2 .lt. ADTIL) then
            af2_tiller = min(af2,1.0)
         else
            af2_tiller = 1.0
         endif
 
         if (af2 .lt. ADPHO) then
            af2_photo = min(af2,1.0)
         else
            af2_photo = 1.0
         endif
      else
         ! No growth effect by AD so set all factors to one.
         af2 = 1.0
         af2_lai = 1.0
         af2_tiller = 1.0
         af2_photo = 1.0
      endif
 
      return
      end subroutine nwheats_set_adf
C=======================================================================
C  nwheats_ad_rtloss, Subroutine  
C    Returns 
C    (another) new routine for senthold's stuff.
C-----------------------------------------------------------------------
C  REVISION HISTORY
C  03/02/2012  FSR adapted from nwheats
!-----------------------------------------------------------------------
C  Called by: nwheats_set_adf
C  Calls    : nwheats_level
C=======================================================================
      SUBROUTINE nwheats_ad_rtloss (CONTROL,
     &                !Input 
     &                !Input
     &                !Input
     &    )           !Output

!     ------------------------------------------------------------------
      USE ModuleDefs    
      IMPLICIT NONE
      SAVE
  
      integer count_of_real_vals
      real dlayr_nw              !
      real layer_top (mxlayr)    ! depth of top of each layer
      real layer_bottom (mxlayr) ! depth of bottom of each layer
      real layer_root(mxlayr)    ! root wt in each layer
      real layer_rootn(mxlayr)   ! root n in each layer
      real kill_fraction         ! fraction of roots to kill in a layer
      real incorp_root(mxlayr)   ! root to incorporate in each layer
      real incorp_rootn(mxlayr)  ! root N to incorporate in each layer
      real kill_depth            ! depth below which we kill roots
      integer kill_layer         ! layer that includes kill_depth
      integer layer              ! layer number
      integer mxlayr             ! 
      integer nrlayr             ! number of layers with roots
      character string*(1000)    ! output string
      real effective_water_table ! effective water table depth (mm)
      real rtdep_nw
      
 
      ! FIND THE NUMBER OF LAYERS WITH ROOTS
      ! ------------------------------------
      nrlayr = nwheats_level (rtdep_nw, dlayr_nw, mxlayr)
 
      ! FIND THE EFFECTIVE WATER TABLE THAT ACCOUNTS FOR P3AF
      ! -----------------------------------------------------
      effective_water_table = g_water_table + P3AF   ! P3AF for p3af
 
      ! RECORD THE TIME OF AERATION DEFICIT FOR EACH LAYER
      ! --------------------------------------------------
      ! AND THE TOP AND BOTTOM DEPTH OF EACH LAYER
      ! ------------------------------------------
      do 100 layer = 1, nrlayr
         if (layer.eq.1) then
            layer_top(layer) = 0.0
            layer_bottom(layer) = dlayr_nw(layer)
         else
            layer_top(layer) = layer_bottom(layer-1)
            layer_bottom(layer)= layer_bottom(layer-1) + dlayr_nw(layer)
         endif
 
         if (effective_water_table.lt. layer_bottom(layer)) then
            ! the top of the water table is above the lower
            ! boundary of this layer.
            ad_time(layer) = ad_time(layer) + 1
         else
            ad_time(layer) = 0
         endif
 
  100 continue
 
      ! FIND THE DEPTH BELOW WHICH ANY ROOTS NEED TO BE KILLED
      ! ------------------------------------------------------
      do 200 layer = 1, nrlayr
         if (ad_time(layer) .ge. P4AF) then
            kill_depth = effective_water_table
            kill_depth = min(kill_depth, rtdep)
            if (kill_depth.lt.rtdep) then
               goto 201
            else
               kill_depth = 0.0
            endif
         else
            kill_depth = 0.0
         endif
  200 continue
  201 continue
 
      ! SEE IF WE NEED TO INCORPORATE ANY ROOT MATERIAL
      ! -----------------------------------------------
      if (kill_depth .gt. 0.0) then
 
         write (string, '(a,f6.1,a,i3)')
     :                  'Killing all roots below ',kill_depth,
     :                  ' mm due to water logging on day ',day_of_year
         call write_string (lu_summary_file, string)
 
 
         ! GET THE DISTRIBUTION OF ROOT MATERIAL IN PROFILE
         ! ------------------------------------------------
         call nwheats_root_distrib (layer_root
     :                          , pl_wt(root) * plants * gm2kg /sm2ha)
         call nwheats_root_distrib (layer_rootn
     :                          , pl_nit(root) * plants * gm2kg /sm2ha)
 
         call fill_real_array (incorp_root,0.0,mxlayr)
         call fill_real_array (incorp_rootn,0.0,mxlayr)
         kill_layer = find_layer_no (kill_depth, dlayr_nw, mxlayr)
 
         ! RECALCULATE POOLS FROM KILL_LAYER DOWN
         ! --------------------------------------
         do 300 layer = kill_layer, nrlayr
 
            ! CALCULATE FRACTION OF LAYER TO KILL
            ! -----------------------------------
            if ((layer.eq.kill_layer).and.(layer.ne.nrlayr)) then
 
              kill_fraction = 1.0 -
     :                        divide(kill_depth - layer_top(kill_layer)
     :                              ,dlayr_nw(kill_layer)
     :                              ,0.0)
            else
              kill_fraction = 1.0
            endif
 
            if (kill_fraction.lt.1.0) then
               ! keep the timer going
            else
               ! no roots left - reset the timer
               ad_time(layer) = 0
            endif
 
            incorp_root(layer) = layer_root(layer)*kill_fraction
            incorp_rootn(layer) = layer_rootn(layer)*kill_fraction
            pl_wt(root) = pl_wt(root) - incorp_root(layer)
     :                                /(plants * gm2kg /sm2ha)
            pl_nit(root) = pl_nit(root) - incorp_rootn(layer)
     :                                /(plants * gm2kg /sm2ha)
            rlv(layer) = rlv(layer) * (1. - kill_fraction)
 
  300    continue
         rtdep = kill_depth
 
         ! BUILD THE MESSAGE TO SEND FOR SOILN TO INCORPORATE
         ! --------------------------------------------------
         !             FRESH ORGANIC MATERIAL
         !             ----------------------
 
         call New_PostBox ()
 
         call post_char_var   ('dlt_fom_type'
     :                        ,'()'
     :                        ,crop_type)
 
         call post_real_array ('dlt_fom_wt'
     :                        ,'(kg/ha)'
     :                        , incorp_root
     :                        ,nrlayr)
 
         call post_real_array ('dlt_fom_n'
     :                        ,'(kg/ha)'
     :                        , incorp_rootn
     :                        ,nrlayr)
 
        string = blank
        call message_send_immediate (all_active_modules
     :                              ,'incorp_fom'
     :                              ,string)
 
        call Delete_PostBox ()
 
      else
      endif
 
      return
      end





C=======================================================================
! ADLAI     threshold aeration deficit (AF2) affecting LAI
! ADTIL     threshold aeration deficit (AF2) affecting tillering
! ADPHO     threshold aeration deficit (AF2) affecting photosyn.
! CUMDEP    !Cumulative depth of soil, cm
! CUMDTT    !Cumulative daily thermal time after germination, C
! DEPMAX    !Depth of soil, cm
! DLAYR(L)  Soil thickness in layer L (cm)
! dlayr_nw(L) Soil thickness in layer L (mm) NWHEAT
! DTT       !Growing degrees occurring today (Base 8C), C      
! ESW(20)   !Extractable water in soil layer L, cm
! GRORT     !Root growth rate, g/plant/day
! ISTAGE    !Crop growth stage (1-9)
!RISWNIT*1  !Switch indicating if soil nitrogen balance is on (Y/N)
! L         !Loop counter
! L1        !Loop counter
! LL(20)    !Volumetric lower limit of soil water in soil layer L, cm3/cm3
! NH4(20)   !Ammonium in soil layer L, ppm
! NLAYR     !Number of soil layers
! NO3(20)   !Nitrate in soil layer L, ppm
! PLTPOP    !Plant population, pl/m2
! RLDF(20)  !A root length density factor for soil layer L used to calculate
!           !new root growth distribution - unitless
! RLNEW     !New root length to be added to the total root system length, cm. root cm2 ground
! RLV(20)   !Root length density, cm root/cm2 soil
! RLWR      !Root length to weight ratio, cm/g
! RNFAC     !Zero to unity factor describing mineral N availability effect on
!           !root growth in Layer L
! RNLF      !Intermediate factor used to calculate distribution of new root
!           !growth in the soil - unitless value between 0 and 1
! RTDEP     !Rooting depth (cm), Initially set at emergence
! SDEPTH    !Sowing depth, cm
! SHF(20)   !Relative root distribution in soil layer L (0-1)
! STGDOY(20)!Year and day of year that a growth stage occurred on
! SW(20)    !Volumetric soil water content of soil layer L, cm3/cm3
! SWDF      !Soil water deficit factor for Layer L used to calculate root
!           !growth and water uptake - unitless value between 0 and 1
! SWFAC     !Soil water stress effect on growth (0-1), 1 is no stress, 0 is full stress
! TRLDF     !An intermediate calculation used to calculate distribution of new root growth in soil
! YRDOY     !Year and day of year  



